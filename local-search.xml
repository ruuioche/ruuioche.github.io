<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>嵌入式复习（杂）</title>
    <link href="/2022/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0%EF%BC%88%E6%9D%82%EF%BC%89/"/>
    <url>/2022/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0%EF%BC%88%E6%9D%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="arm部分"><a href="#arm部分" class="headerlink" title="arm部分"></a>arm部分</h1><ol><li>switch语句<br>CASE_0       CMP          R2,#0     <br>CASE_2       CMPNE     R2,#2            <br>CASE_3       CMPNE     R2,#3  <br>表示的意思为  CMP中如果 R2 &#x3D;&#x3D; 0 则执行CMP下的语句（斜接上一条语句）<br>CMPNE判断条件斜接上一条的R2 &#x3D;&#x3D; 0 如果不等则判断 R2 &#x3D;&#x3D; 2<br>如果等于则执行他的指令  如果不等 则下一条指令去判断  R2 &#x3D;&#x3D; 3<br>CASE_3       CMPNE     R2,#3             <br>                     BNE        CASE_5 <br>                     ADD        R0,R2,R1       <br>                     B              SWITCH_END      <br>CASE_5       CMP              R2,#5             <br>                     BNE        CASE_7<br>                     SUB        R0,R2,R1       <br>                     B            SWITCH_END     <br>CASE_7       CMP       R2,#7             <br>                     BNE        DEFAULT            <br>                     MUL       R0,R2,R1       <br>                     B             SWITCH_END  <br>DEFAULT    MOV      R0,#168         <br>指令执行到 CMPNE  R2 &#x3D;&#x3D; 3时，接下一条指令，如果BNE判断为不等则跳到case 5<br>如果相等则继续下一条指令 开始计算  计算结束后无条件跳转到结束<br>跳转到case 5时因为上条指令没有判断体   因此此处为CMP 判断R2 &#x3D;&#x3D; 5（这里是为了指令判断的条件？）<br>之后BNE用指令 如果不等则跳出 如果相等则跳过这条指令  执行计算 CASE7同理</li><li>for循环<br>循环语句体：<br>MOV R0，#loop_count &#x2F;&#x2F;将循环次数的值赋值给R0<br>loop<br>… …<br>SUBS R0，R0，#1  &#x2F;&#x2F;直接对寄存器操作  R0-1<br>BNE loop 如果减的结果不等于0 则跳转到loop继续执行。<br>for(i&#x3D;0; i&lt;10; i++)<br>{  x++;<br>}<br>for循环举例<br>  MOV             R0,#0             &#x2F;&#x2F;初始化R0为0<br>  MOV             R2,#0             &#x2F;&#x2F;初始化R2为0（i）<br>FOR_L1         <br> CMP              R2,#10           &#x2F;&#x2F;判断i是否&lt;10<br>    BHS        FOR_END           &#x2F;&#x2F;HS无符号数大于等于  如果大于等于10则跳转到结束</li></ol><p>                    <br>    ADD       R0,R0,#1           &#x2F;&#x2F;如果不是则继续这条指令 R0++ <br>                    <br>    ADD       R2,R2,#1    &#x2F;&#x2F;i++<br>    B          FOR_L1        然后无条件跳转到新一轮的循环中去<br>FOR_END             NOP   &#x2F;&#x2F;结束的位置，空指令<br>arm的三级流水线 取址   译码    执行<br>PC的值 &#x3D; 当前正在执行指令在内存中的地址 + 8 </p><h1 id="s3c2410"><a href="#s3c2410" class="headerlink" title="s3c2410"></a>s3c2410</h1><ol><li><p>s3c2410看门狗<br> watchdog的操作<br>  在开启看门狗之前，我们必需在寄存器wtdat里面存放一个值，在watchdog开启之后这个值会被自动加载进寄存器wtcnt中<br>  （看门狗记数寄存器）<br>  看门狗根据PCLK，prescaler value，clock select产生一个看门狗自己的工作周期，记为t_watchdog，watchdog在一个周期<br>  结束时产生一个记数递减信号，信号产生时，wtcnt中的值减一，若在wtcnt递减为0（Timer Out）的时候软件层还没有重新往WTCNT<br>  中写入数值（喂狗），看门狗触发Reset Signal，系统重启。<br>设置并开启watchdog的程序：<br>  void enable_watchdog()<br>  {<br> rWTCON &#x3D; 0x7F81; &#x2F;&#x2F;0111 1111 1000 0001   预分频器值（127）<br> rWTDAT &#x3D; 0x8000; &#x2F;&#x2F;1000 0000 0000 0000  [15:0] 表示计数常数值 计算可得<br> rWTCON|&#x3D;1&lt;&lt;5; &#x2F;&#x2F;1左移5位  或运算让WTCON【5】为1，使能看门狗定时器<br>  }<br>rWTCON，rWTDAT分别为寄存器WTCON，WTDAT的地址解引用，我如下定义他们<br>#define       rWTCON               (*(volatile unsigned int <em>)0x53000000)<br>#define       rWTDAT               (</em>(volatile unsigned int *)0x53000004)<br>从上面的设置我们可知寄存器WTCON的值为0x7F81，分解出来得：<br>Prescaler Value              &#x3D;255<br>Division_factor               &#x3D;16(Clock Select&#x3D;16)<br>Interrupt Generation      &#x3D;0(不产生中断)<br>Reset                           &#x3D;1(开启Reset Signal)<br>第4行设置寄存器WTDAT的值为0x8000。<br>第5行开启watchdog<br>当调用上面的函数之后，你的系统已经开启了watchdog，所以你必须在WTCNT中的值递减到0之前重新往该寄存器写入一个非0值(feed dog)，否则将引起系统重起,以下是feed_dog函数<br>void feed_dog()<br>{<br>       rWTCNT&#x3D;0x8000;<br>}<br>下面是void enable_watchdog()和feed_dog()配合使用的一个例子<br>void main()<br>{<br>       init_system();<br>       .<br>       …<br>       …..<br>       enable_watchdog();<br>       .<br>       …<br>       …..<br>       while(1)<br>       {<br>               feed_dog();       <br>       }<br>}<br>在这个例子中我假设了main函数是系统的主函数，在做完一系列系统初始化之后enable_watchdog()函数被调用，此时watchdog被启 动，下面的while循环则是不断的进行feed_dog，使系统不发生重起。当然在实际应用中不可能采取这种架构来对watchdog进行操作，一般来 说feed_dog函数的调用是被安插在定时器的中断服务例程中，当然，定时器的time out（注意是定时器的time out,不是watchdog的 time out）时间长度必须合适，否则在定时器还没来得及发生中断调用feed_dog函数之前，watchdog已经time out了，那也将引起系统重起.<br>注1：事实上，WTDAT和WTCNT这两个寄存器在系统上电之后会被硬件自动的填入两个初始值0x8000，开启watchdog之后， WTCNT并没有马上就把WTDAT中的值装入，而是使用初始值0x8000。在发生第一次time out之后，WTDAT寄存器中的值才会被真正的装载进WTCNT寄存器中。<br>注2：t_watchdog可根据公式对其进行计算：<br>t_watchdog&#x3D; 1&#x2F; (PCLK &#x2F; (Prescaler value + 1) &#x2F; Division_factor)<br>Prescaler Value位于寄存器WTCON的8至15位，其值为0<del>255<br>Division_factor由寄存器WTCON中的3</del>4位(Clock Select)决定，其值可以为00，01，10，11分别代表Division_factor的值为16，32，64，128</p><h1 id="51单片机学习记录"><a href="#51单片机学习记录" class="headerlink" title="51单片机学习记录"></a>51单片机学习记录</h1><h2 id="统一使用的延时函数"><a href="#统一使用的延时函数" class="headerlink" title="统一使用的延时函数"></a>统一使用的延时函数</h2><p>  void DelayMS（uint x）<br> {<br>   uchar i;<br>   while(x–)<br>   {<br> for(i&#x3D;0;i&lt;120;i++);<br>   }<br> }</p><h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2></li><li><p>led灯闪烁<br>   首先配置LED灯接p1.0口  sbit lED&#x3D;P1^0<br>   延时并反转LED &#x3D; ~LED即可</p></li><li><p>流水灯<br>   P0 &#x3D; 0xfe<br>   P0&#x3D;<em>crol</em>(P0,1);&#x2F;&#x2F;效果就是 1111 1110、1111 1101、1111 1011，如同一条圆形纸带一样循环<br>   0位循环移动，循环开启io口来点亮led灯<br>   （ps：同理P2&#x3D;<em>cror</em>(P2,1); &#x2F;&#x2F;P2 的值向右循环移动）<br>  重点 05 led模拟交通灯<br>   东西向绿灯亮若干秒，黄灯闪烁五次之后红灯亮，东西向红灯亮的同时，南北向红灯变绿灯，若干秒后，南北向绿灯变黄灯闪烁五次之后红灯亮。<br>   程序：<br>   sbit RED_A &#x3D; P0^0; &#x2F;&#x2F;东西向红灯接p0.0口且两个灯并联<br>   sbit YELLOW_A &#x3D; P0^1;<br>   sbit GREEN_A &#x3D; P0^2;</p><p>   sbit RED_B &#x3D; P0^3; &#x2F;&#x2F;南北向红灯，接入逻辑同东西向<br>   sbit YELLOW_B &#x3D; P0^4;<br>   sbit GREEN_B &#x3D; P0^5;</p><p>   uchar Flash_Count &#x3D; 0; &#x2F;&#x2F;闪烁记数<br>   Operation_Type &#x3D; 1; &#x2F;&#x2F;操作类型变量<br>   void DelayMS(uint x); &#x2F;&#x2F;同上</p><p>   void Traffic_light()<br>   {<br> switch(Operaion_Type)<br> {<br>   case 1: &#x2F;&#x2F;东西绿 南北 红<br>     RED_A &#x3D; 1;YELLOW_A&#x3D;1;GREEN_A&#x3D;0;  &#x2F;&#x2F;0为亮<br>     RED_B&#x3D;0;YELLOW_B&#x3D;1;GREEN_B&#x3D;1;<br>     DelayMS(2000);<br>     Opration_Type&#x3D;2;<br>   case 2: &#x2F;&#x2F;东西黄闪 南北红<br>     DelayMS(300);<br>     YELLOW_A &#x3D; ~YELLOW_A;GREEN_A&#x3D;1;<br>     if(++Flash_Count!&#x3D;10)return; &#x2F;&#x2F;闪烁5次 因为并联 因此这里用10记数<br>     Flash_Count&#x3D;0;&#x2F;&#x2F;归零<br>     Operation_Type&#x3D;3;<br>   case 3: &#x2F;&#x2F;东西变红 南北绿<br>     RED_A &#x3D; 0;YELLOW_A&#x3D;1;GREEN_A&#x3D;1;<br>     RED_B&#x3D;1;YELLOW_B&#x3D;1;GREEN_B&#x3D;0;<br>     DelayMS(2000);<br>     Operaion_Type &#x3D; 4;<br>   case 4: &#x2F;&#x2F;南北闪黄<br>     DelayMS(300);<br>     YELLOW_B &#x3D; ~YELLOW_B;GREEN_B&#x3D;1;<br>     if(++Flash_Count!&#x3D;10) return;<br>     Flash_Count&#x3D;0;<br>     Operaion_Type&#x3D;1;<br> }<br>   }</p><p>   void main()<br>   {<br> while(1)<br>   Traffic_Light(); &#x2F;&#x2F;主程序调用即可<br>   }</p></li><li><p>单只数码管循环显示0<del>9<br> uchar code DSY_CODE[]&#x3D;{0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff}; &#x2F;&#x2F;数码管上对应位置点亮，之后共同显示数据 s3c不同于c51注意区别<br> void main()<br> {<br>   uchar i&#x3D;0;<br>   P0&#x3D;0x00;  0-7口全开<br>   while(1)<br>   {<br>     P0&#x3D;</del>DSY_CODE[i]; &#x2F;&#x2F;循环显示<br>     i&#x3D;(i+1)%10;<br>     DelayMS(300);<br>   }<br> }</p></li><li><p>K1-K4按键控制LED灯移位<br>   此处未使用中断来控制<br>   void Move_LED()<br>   {&#x2F;&#x2F;通过键位来判断是否按下按键<br>  if ((P1&amp;0x10)&#x3D;&#x3D;0) P0&#x3D;<em>cror</em>(P0,1); &#x2F;&#x2F;K1<br>  else if((P1&amp;0x20)&#x3D;&#x3D;0) P0&#x3D;<em>crol</em>(P0,1); &#x2F;&#x2F;K2<br> else if((P1&amp;0x40)&#x3D;&#x3D;0) P2&#x3D;<em>cror</em>(P2,1); &#x2F;&#x2F;K3<br>   else if((P1&amp;0x80)&#x3D;&#x3D;0) P2&#x3D;<em>crol</em>(P2,1); &#x2F;&#x2F;K4<br>   }</p><p>   void main()<br>   {<br> uchar Recent_Key; &#x2F;&#x2F;最近按键<br> P0&#x3D;0xfe; &#x2F;&#x2F;1111 1110<br> P2&#x3D;0xfe;<br> P1&#x3D;0xff;<br> Recent_Key &#x3D; 0xff;<br> while(1)<br> {<br>   if(Recent_Key!&#x3D;P1)<br>   {<br>     Recnet_Key&#x3D;P1;<br>     Move_LED();<br>     Delay_MS(10);<br>   }<br> }<br>   }</p></li><li><p>按键分组控制LED灯<br> 按下K1递增点亮一只LED，全亮时再按下则再次循环<br> 按下k2点亮上面四只LED  按下k3点亮下面四只LED，K4按下关闭所有LED</p><h2 id="80c51定时器工作模式"><a href="#80c51定时器工作模式" class="headerlink" title="80c51定时器工作模式"></a>80c51定时器工作模式</h2><p>   80c51系列单片机有2个16位的定时器&#x2F;计数器：定时器0（T0），定时器1（T1） 都有定时器或事件计数的功能<br>   T0由两个特殊功能寄存器TH0和TL0构成，T1则由TH1和TL1构成，均是16位加法计数结构<br>   作计数器时，通过引脚T0(P3.4)和T1(P3.5)对外部脉冲信号计数，当输入脉冲信号从1到0的负跳变时，计数器就自动加1，计数的最高频率一般为振荡频率的1&#x2F;24<br>   不论是定时或计数工作，定时器T0或T1都不占用CPU时间，除非定时器（计数器）溢出，才可能中断CPU当前操作<br>   每个定时器都需要一个时钟才能工作，8051通过外部晶振提供它，这是Timer的主要时钟源。8051微控制器中的内部电路为定时器提供时钟源，该定时器是连接到微控制器的晶体频率的1&#x2F;12，也称为机器周期频率。<br>   8051定时器时钟<br>   例如，假设我们的晶振频率为11.0592 MHz，那么微控制器将提供1&#x2F;12即：<br>   定时器时钟频率&#x3D;（Xtal Osc.frequency）&#x2F; 12 &#x3D;（11.0592 MHz）&#x2F; 12 &#x3D; 921.6 KHz<br>   周期T &#x3D; 1 &#x2F;（921.6KHz）&#x3D;1.085μS<br>   方式0为13位的计数器，由TL0的低5位和TH0的8位组成，TL0的高3位未用，TL0低5位计数溢出时向TH0进位，TH0计数溢出时，向中断标志位TF0进位(硬件置位TF0)，并申请中断。T0是否溢出可查询TF0是否被置位，以产生T0中断。<br>   方式0定时，定时时间为：to&#x3D;(213- Xo) xTm&#x3D;(213-X0) x(12&#x2F; fosc)<br>   式中X0为计数初值，Tm为机器周期，fosc为 晶振频率。方式0计数时，最大计数值为2^13&#x3D;8192 (个外部脉冲)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>arm</category>
      
      <category>s3c2410</category>
      
      <category>51单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
