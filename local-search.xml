<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构复习笔记（杂）</title>
    <link href="/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9D%82%EF%BC%89/"/>
    <url>/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9D%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="图部分代码整理与拓展"><a href="#图部分代码整理与拓展" class="headerlink" title="图部分代码整理与拓展"></a>图部分代码整理与拓展</h1><ol><li>判断无向图是否为一棵树<br> 条件是：无向图必须是无回路的连通图或有n-1条边的连通图，连通的判断：深度搜索遍历图并统计可能访问到的顶点个数和边数，若一次遍历可以访问n个顶点与n-1条边，则此图为树 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isTree</span><span class="hljs-params">(Graph&amp; G)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=G.vexnum;i++)<br>    &#123;<br>        visited[i] = FALSE; <span class="hljs-comment">//初始化</span><br>    &#125;<br>    <span class="hljs-type">int</span> Vnum=<span class="hljs-number">0</span>,Enum=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录顶点数和边数</span><br>    DFS(G,<span class="hljs-number">1</span>,Vnum,Enum,visited);<br>    <span class="hljs-keyword">if</span>(Vnum == G.vexnum &amp;&amp; Enum==<span class="hljs-number">2</span>*(G.vexnum<span class="hljs-number">-1</span>))<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(Graph&amp; G,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span>&amp; Vnum,<span class="hljs-type">int</span>&amp; Enum,<span class="hljs-type">int</span> visited[])</span><br>&#123;<br>    visited[v]=TRUE;Vnum++; <span class="hljs-comment">//访问该结点</span><br>    <span class="hljs-type">int</span> w=FirstNeighbor(G,v); <span class="hljs-comment">//v的第一个邻接结点</span><br>    <span class="hljs-keyword">while</span>(w != <span class="hljs-number">-1</span>)  <span class="hljs-comment">//邻接结点存在</span><br>    &#123;<br>        Enum++;   <span class="hljs-comment">//边计数</span><br>        <span class="hljs-keyword">if</span>(!visited[w])<br>        &#123;<br>            DFS(G,w,Vnum,Enum,visited);<br>        &#125;<br>        w = NextNeighbor(G,v,w); <span class="hljs-comment">//回溯</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>并查集实现（待完成）<br></code></pre></td></tr></table></figure></li><li>深度搜索的非递归实现  图使用邻接表形式存储<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DFS_Non_RC</span><span class="hljs-params">(AGraph&amp; G,<span class="hljs-type">int</span> v)</span><br>&#123;<br>    <span class="hljs-type">int</span> w; <span class="hljs-comment">//顶点序号</span><br>    Init_Stack(S);  <span class="hljs-comment">//初始化栈S</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; G.vexnum;i++)<br>    &#123;<br>        visited[i] = FALSE;<br>    &#125;<br>    Push(S,v); visited[v] = TRUE; <span class="hljs-comment">//v入栈且修改访问标记</span><br>    <span class="hljs-keyword">while</span>(!IsEmpty(S))<br>    &#123;<br>        k=Pop(S); <span class="hljs-comment">//栈中退出一个顶点</span><br>        visit(k);  <span class="hljs-comment">//访问该结点之后将其子结点入栈</span><br>        <span class="hljs-keyword">for</span>(w = FirstNeighbor(G,k);w&gt;=<span class="hljs-number">0</span>;w=NextNeighbor(G,k,w))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[w])  <span class="hljs-comment">//未进过栈的顶点进栈</span><br>            &#123;<br>                Push(S,w);<br>                visited[w] = TRUE;  <span class="hljs-comment">//标记一下防止再次进入栈</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>邻接表存储图 寻找是否存在从顶点i到顶点j的路径<br>广度优先：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-type">int</span> visited[MAXSIZE] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//访问标志</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(ALGraph&amp; G,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span><br>    &#123;<br>        InitQueue(Q); <span class="hljs-comment">//初始化队列</span><br>        EnQueue(i);<br>        <span class="hljs-keyword">while</span>(!IsEmpty(Q))<br>        &#123;<br>            DeQueue(Q,u);<br>            visited[u] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(u == j)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p = FirstNeighbor(G,u);p;p=NextNeighbor(G,u,p))<br>            &#123;<br>                <span class="hljs-keyword">if</span>(p == j)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(!visited[p])<br>                &#123;<br>                    EnQueue(Q,p);<br>                    visited[p] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;  <br>        &#125;<br>    &#125;<br><br>深度优先遍历：<br>    <span class="hljs-type">int</span> visited[MAXSIZE]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(ALGraph&amp; G,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">bool</span> &amp;can_reach)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(i==j)<br>        &#123;<br>            can_reach=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        visited[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=FirstNeighbor(G,i);p&gt;=<span class="hljs-number">0</span>;p=NextNeighbor(G,i,p))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[p] &amp;&amp; !can_reach)<br>            &#123;<br>                DFS(G,p,j,can_reach);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>使用邻接表存储图  输出顶点vi到vj的所有简单路径<br>补充：简单路径的概念：路径上的结点均不重复<br>path[]用来存储路径  d用来存储路径的长度<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FindPath</span><span class="hljs-params">(AGraph *G,<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> path[],<span class="hljs-type">int</span> d)</span><br>&#123;<br>    <span class="hljs-type">int</span> w,i;<br>    ArcNode *p;<br>    d++;<br>    path[d] = u;  <span class="hljs-comment">//放入顶点</span><br>    <span class="hljs-keyword">if</span>(u == v)<br>    &#123;<br>        print(path[]); <span class="hljs-comment">//找到路径就输出</span><br>    &#125;<br>    p = G-&gt;adjlist[u].fistarc; <span class="hljs-comment">//指向u的第一个相邻点</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        w=p-&gt;adjvex;  <span class="hljs-comment">//顶点位置</span><br>        <span class="hljs-keyword">if</span>(visited[w] == <span class="hljs-number">0</span>)<br>        &#123;<br>            FindPath(G,w,v,path,d);<br>        &#125;<br>        p=p-&gt;nextarc; <span class="hljs-comment">//指向u的下一个相邻点</span><br>    &#125;<br>    visited[u] = <span class="hljs-number">0</span>; <span class="hljs-comment">//继续寻找</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>由上题进行邻接表存储结构的复习 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100 <span class="hljs-comment">//图中顶点最大数目</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>&#123;</span>  <span class="hljs-comment">//边表结点</span><br>    <span class="hljs-type">int</span> adjvex; <span class="hljs-comment">//该弧所指向的顶点的位置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>* <span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指向下一条弧的指针</span><br>    <span class="hljs-comment">// InfoType info; //网的边权值</span><br>&#125;ArcNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VNode</span>&#123;</span>  <span class="hljs-comment">//顶点表结点</span><br>    VertexType data;  <span class="hljs-comment">//顶点信息</span><br>    ArcNode* first; <span class="hljs-comment">//指向第一条依附于该顶点的弧的指针</span><br>&#125;VNode,AdjList[MaxVertexNum];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    AdjList vertices; <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> vexnum,arcnum;<span class="hljs-comment">//顶点数  弧数</span><br>&#125;ALGraph;<br></code></pre></td></tr></table></figure></li><li>拓扑排序 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">TopologicalSort</span><span class="hljs-params">(Graph G)</span><br>&#123;<br>    InitStack(S); <span class="hljs-comment">//初始化一个存储入度为0的点的栈</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;G.vexnum ; i++)<br>    &#123;<br><br>        <span class="hljs-keyword">if</span>(indegree[i] == <span class="hljs-number">0</span>)<br>        &#123;<br><br>            Push(S,i);    <span class="hljs-comment">//将入度为0的点加入栈中  </span><br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录当前已经输出的顶点数</span><br><br>    <span class="hljs-keyword">while</span>(!IsEmpty(S))  <span class="hljs-comment">//栈不空存在入度为0的点</span><br>    &#123;<br>        Pop(S,i);  <span class="hljs-comment">//栈顶元素出栈</span><br>        print[count++]=i; <span class="hljs-comment">//输出顶点i</span><br>        <span class="hljs-keyword">for</span>(p=G.vertices[i].firstarc;p;p=-&gt;nextarc)<br>        &#123;<br>            v=p-&gt;adivex;<br>            <span class="hljs-keyword">if</span>(!(--indegree[v]))<br>            &#123;<br>                Push(S,v);  <span class="hljs-comment">//入度减为0，入栈</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(count&lt;G.vexnum)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 拓展文章：<a href="https://cherish-ls.github.io/2020/09/15/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/">https://cherish-ls.github.io/2020/09/15/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/</a></li><li>三角邻接矩阵的意义<br> (未整理)<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><h2 id="顺序查找-折半查找"><a href="#顺序查找-折半查找" class="headerlink" title="顺序查找  折半查找"></a>顺序查找  折半查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *elem; <span class="hljs-comment">//元素存储空间基址，建表时按实际长度分配，0号单元留空</span><br>    <span class="hljs-type">int</span> TableLen; <span class="hljs-comment">//表的长度</span><br>&#125;SSTable;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST,ST,ElemType key)</span><br>&#123;<br>    ST.elem[<span class="hljs-number">0</span>]=key; <span class="hljs-comment">//哨兵</span><br>    <span class="hljs-keyword">for</span>(i=ST.TableLen;ST.elem[i]!=key;--i)<br>    &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 线性的链表只能顺序查找<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><h2 id="B树查找"><a href="#B树查找" class="headerlink" title="B树查找"></a>B树查找</h2></li></ol>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式复习（杂）</title>
    <link href="/2022/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0%EF%BC%88%E6%9D%82%EF%BC%89/"/>
    <url>/2022/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0%EF%BC%88%E6%9D%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="arm部分"><a href="#arm部分" class="headerlink" title="arm部分"></a>arm部分</h1><ol><li>switch语句<br>CASE_0       CMP          R2,#0     <br>CASE_2       CMPNE     R2,#2            <br>CASE_3       CMPNE     R2,#3  <br>表示的意思为  CMP中如果 R2 &#x3D;&#x3D; 0 则执行CMP下的语句（斜接上一条语句）<br>CMPNE判断条件斜接上一条的R2 &#x3D;&#x3D; 0 如果不等则判断 R2 &#x3D;&#x3D; 2<br>如果等于则执行他的指令  如果不等 则下一条指令去判断  R2 &#x3D;&#x3D; 3<br>CASE_3       CMPNE     R2,#3             <br>                     BNE        CASE_5 <br>                     ADD        R0,R2,R1       <br>                     B              SWITCH_END      <br>CASE_5       CMP              R2,#5             <br>                     BNE        CASE_7<br>                     SUB        R0,R2,R1       <br>                     B            SWITCH_END     <br>CASE_7       CMP       R2,#7             <br>                     BNE        DEFAULT            <br>                     MUL       R0,R2,R1       <br>                     B             SWITCH_END  <br>DEFAULT    MOV      R0,#168         <br>指令执行到 CMPNE  R2 &#x3D;&#x3D; 3时，接下一条指令，如果BNE判断为不等则跳到case 5<br>如果相等则继续下一条指令 开始计算  计算结束后无条件跳转到结束<br>跳转到case 5时因为上条指令没有判断体   因此此处为CMP 判断R2 &#x3D;&#x3D; 5（这里是为了指令判断的条件？）<br>之后BNE用指令 如果不等则跳出 如果相等则跳过这条指令  执行计算 CASE7同理</li><li>for循环<br>循环语句体：<br>MOV R0，#loop_count &#x2F;&#x2F;将循环次数的值赋值给R0<br>loop<br>… …<br>SUBS R0，R0，#1  &#x2F;&#x2F;直接对寄存器操作  R0-1<br>BNE loop 如果减的结果不等于0 则跳转到loop继续执行。<br>for(i&#x3D;0; i&lt;10; i++)<br>{  x++;<br>}<br>for循环举例<br>  MOV             R0,#0             &#x2F;&#x2F;初始化R0为0<br>  MOV             R2,#0             &#x2F;&#x2F;初始化R2为0（i）<br>FOR_L1         <br> CMP              R2,#10           &#x2F;&#x2F;判断i是否&lt;10<br>    BHS        FOR_END           &#x2F;&#x2F;HS无符号数大于等于  如果大于等于10则跳转到结束</li></ol><p>                    <br>    ADD       R0,R0,#1           &#x2F;&#x2F;如果不是则继续这条指令 R0++ <br>                    <br>    ADD       R2,R2,#1    &#x2F;&#x2F;i++<br>    B          FOR_L1        然后无条件跳转到新一轮的循环中去<br>FOR_END             NOP   &#x2F;&#x2F;结束的位置，空指令<br>arm的三级流水线 取址   译码    执行<br>PC的值 &#x3D; 当前正在执行指令在内存中的地址 + 8 </p><h1 id="s3c2410"><a href="#s3c2410" class="headerlink" title="s3c2410"></a>s3c2410</h1><ol><li><p>s3c2410看门狗<br> watchdog的操作<br>  在开启看门狗之前，我们必需在寄存器wtdat里面存放一个值，在watchdog开启之后这个值会被自动加载进寄存器wtcnt中<br>  （看门狗记数寄存器）<br>  看门狗根据PCLK，prescaler value，clock select产生一个看门狗自己的工作周期，记为t_watchdog，watchdog在一个周期<br>  结束时产生一个记数递减信号，信号产生时，wtcnt中的值减一，若在wtcnt递减为0（Timer Out）的时候软件层还没有重新往WTCNT<br>  中写入数值（喂狗），看门狗触发Reset Signal，系统重启。<br>设置并开启watchdog的程序：<br>  void enable_watchdog()<br>  {<br> rWTCON &#x3D; 0x7F81; &#x2F;&#x2F;0111 1111 1000 0001   预分频器值（127）<br> rWTDAT &#x3D; 0x8000; &#x2F;&#x2F;1000 0000 0000 0000  [15:0] 表示计数常数值 计算可得<br> rWTCON|&#x3D;1&lt;&lt;5; &#x2F;&#x2F;1左移5位  或运算让WTCON【5】为1，使能看门狗定时器<br>  }<br>rWTCON，rWTDAT分别为寄存器WTCON，WTDAT的地址解引用，我如下定义他们<br>#define       rWTCON               (*(volatile unsigned int <em>)0x53000000)<br>#define       rWTDAT               (</em>(volatile unsigned int *)0x53000004)<br>从上面的设置我们可知寄存器WTCON的值为0x7F81，分解出来得：<br>Prescaler Value              &#x3D;255<br>Division_factor               &#x3D;16(Clock Select&#x3D;16)<br>Interrupt Generation      &#x3D;0(不产生中断)<br>Reset                           &#x3D;1(开启Reset Signal)<br>第4行设置寄存器WTDAT的值为0x8000。<br>第5行开启watchdog<br>当调用上面的函数之后，你的系统已经开启了watchdog，所以你必须在WTCNT中的值递减到0之前重新往该寄存器写入一个非0值(feed dog)，否则将引起系统重起,以下是feed_dog函数<br>void feed_dog()<br>{<br>       rWTCNT&#x3D;0x8000;<br>}<br>下面是void enable_watchdog()和feed_dog()配合使用的一个例子<br>void main()<br>{<br>       init_system();<br>       .<br>       …<br>       …..<br>       enable_watchdog();<br>       .<br>       …<br>       …..<br>       while(1)<br>       {<br>               feed_dog();       <br>       }<br>}<br>在这个例子中我假设了main函数是系统的主函数，在做完一系列系统初始化之后enable_watchdog()函数被调用，此时watchdog被启 动，下面的while循环则是不断的进行feed_dog，使系统不发生重起。当然在实际应用中不可能采取这种架构来对watchdog进行操作，一般来 说feed_dog函数的调用是被安插在定时器的中断服务例程中，当然，定时器的time out（注意是定时器的time out,不是watchdog的 time out）时间长度必须合适，否则在定时器还没来得及发生中断调用feed_dog函数之前，watchdog已经time out了，那也将引起系统重起.<br>注1：事实上，WTDAT和WTCNT这两个寄存器在系统上电之后会被硬件自动的填入两个初始值0x8000，开启watchdog之后， WTCNT并没有马上就把WTDAT中的值装入，而是使用初始值0x8000。在发生第一次time out之后，WTDAT寄存器中的值才会被真正的装载进WTCNT寄存器中。<br>注2：t_watchdog可根据公式对其进行计算：<br>t_watchdog&#x3D; 1&#x2F; (PCLK &#x2F; (Prescaler value + 1) &#x2F; Division_factor)<br>Prescaler Value位于寄存器WTCON的8至15位，其值为0<del>255<br>Division_factor由寄存器WTCON中的3</del>4位(Clock Select)决定，其值可以为00，01，10，11分别代表Division_factor的值为16，32，64，128</p><h1 id="51单片机学习记录"><a href="#51单片机学习记录" class="headerlink" title="51单片机学习记录"></a>51单片机学习记录</h1><h2 id="统一使用的延时函数"><a href="#统一使用的延时函数" class="headerlink" title="统一使用的延时函数"></a>统一使用的延时函数</h2><p>  void DelayMS（uint x）<br> {<br>   uchar i;<br>   while(x–)<br>   {<br> for(i&#x3D;0;i&lt;120;i++);<br>   }<br> }</p><h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2></li><li><p>led灯闪烁<br>   首先配置LED灯接p1.0口  sbit lED&#x3D;P1^0<br>   延时并反转LED &#x3D; ~LED即可</p></li><li><p>流水灯<br>   P0 &#x3D; 0xfe<br>   P0&#x3D;<em>crol</em>(P0,1);&#x2F;&#x2F;效果就是 1111 1110、1111 1101、1111 1011，如同一条圆形纸带一样循环<br>   0位循环移动，循环开启io口来点亮led灯<br>   （ps：同理P2&#x3D;<em>cror</em>(P2,1); &#x2F;&#x2F;P2 的值向右循环移动）<br>  重点 05 led模拟交通灯<br>   东西向绿灯亮若干秒，黄灯闪烁五次之后红灯亮，东西向红灯亮的同时，南北向红灯变绿灯，若干秒后，南北向绿灯变黄灯闪烁五次之后红灯亮。<br>   程序：<br>   sbit RED_A &#x3D; P0^0; &#x2F;&#x2F;东西向红灯接p0.0口且两个灯并联<br>   sbit YELLOW_A &#x3D; P0^1;<br>   sbit GREEN_A &#x3D; P0^2;</p><p>   sbit RED_B &#x3D; P0^3; &#x2F;&#x2F;南北向红灯，接入逻辑同东西向<br>   sbit YELLOW_B &#x3D; P0^4;<br>   sbit GREEN_B &#x3D; P0^5;</p><p>   uchar Flash_Count &#x3D; 0; &#x2F;&#x2F;闪烁记数<br>   Operation_Type &#x3D; 1; &#x2F;&#x2F;操作类型变量<br>   void DelayMS(uint x); &#x2F;&#x2F;同上</p><p>   void Traffic_light()<br>   {<br> switch(Operaion_Type)<br> {<br>   case 1: &#x2F;&#x2F;东西绿 南北 红<br>     RED_A &#x3D; 1;YELLOW_A&#x3D;1;GREEN_A&#x3D;0;  &#x2F;&#x2F;0为亮<br>     RED_B&#x3D;0;YELLOW_B&#x3D;1;GREEN_B&#x3D;1;<br>     DelayMS(2000);<br>     Opration_Type&#x3D;2;<br>   case 2: &#x2F;&#x2F;东西黄闪 南北红<br>     DelayMS(300);<br>     YELLOW_A &#x3D; ~YELLOW_A;GREEN_A&#x3D;1;<br>     if(++Flash_Count!&#x3D;10)return; &#x2F;&#x2F;闪烁5次 因为并联 因此这里用10记数<br>     Flash_Count&#x3D;0;&#x2F;&#x2F;归零<br>     Operation_Type&#x3D;3;<br>   case 3: &#x2F;&#x2F;东西变红 南北绿<br>     RED_A &#x3D; 0;YELLOW_A&#x3D;1;GREEN_A&#x3D;1;<br>     RED_B&#x3D;1;YELLOW_B&#x3D;1;GREEN_B&#x3D;0;<br>     DelayMS(2000);<br>     Operaion_Type &#x3D; 4;<br>   case 4: &#x2F;&#x2F;南北闪黄<br>     DelayMS(300);<br>     YELLOW_B &#x3D; ~YELLOW_B;GREEN_B&#x3D;1;<br>     if(++Flash_Count!&#x3D;10) return;<br>     Flash_Count&#x3D;0;<br>     Operaion_Type&#x3D;1;<br> }<br>   }</p><p>   void main()<br>   {<br> while(1)<br>   Traffic_Light(); &#x2F;&#x2F;主程序调用即可<br>   }</p></li><li><p>单只数码管循环显示0<del>9<br> uchar code DSY_CODE[]&#x3D;{0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff}; &#x2F;&#x2F;数码管上对应位置点亮，之后共同显示数据 s3c不同于c51注意区别<br> void main()<br> {<br>   uchar i&#x3D;0;<br>   P0&#x3D;0x00;  0-7口全开<br>   while(1)<br>   {<br>     P0&#x3D;</del>DSY_CODE[i]; &#x2F;&#x2F;循环显示<br>     i&#x3D;(i+1)%10;<br>     DelayMS(300);<br>   }<br> }</p></li><li><p>K1-K4按键控制LED灯移位<br>   此处未使用中断来控制<br>   void Move_LED()<br>   {&#x2F;&#x2F;通过键位来判断是否按下按键<br>  if ((P1&amp;0x10)&#x3D;&#x3D;0) P0&#x3D;<em>cror</em>(P0,1); &#x2F;&#x2F;K1<br>  else if((P1&amp;0x20)&#x3D;&#x3D;0) P0&#x3D;<em>crol</em>(P0,1); &#x2F;&#x2F;K2<br> else if((P1&amp;0x40)&#x3D;&#x3D;0) P2&#x3D;<em>cror</em>(P2,1); &#x2F;&#x2F;K3<br>   else if((P1&amp;0x80)&#x3D;&#x3D;0) P2&#x3D;<em>crol</em>(P2,1); &#x2F;&#x2F;K4<br>   }</p><p>   void main()<br>   {<br> uchar Recent_Key; &#x2F;&#x2F;最近按键<br> P0&#x3D;0xfe; &#x2F;&#x2F;1111 1110<br> P2&#x3D;0xfe;<br> P1&#x3D;0xff;<br> Recent_Key &#x3D; 0xff;<br> while(1)<br> {<br>   if(Recent_Key!&#x3D;P1)<br>   {<br>     Recnet_Key&#x3D;P1;<br>     Move_LED();<br>     Delay_MS(10);<br>   }<br> }<br>   }</p></li><li><p>按键分组控制LED灯<br> 按下K1递增点亮一只LED，全亮时再按下则再次循环<br> 按下k2点亮上面四只LED  按下k3点亮下面四只LED，K4按下关闭所有LED</p><h2 id="80c51定时器工作模式"><a href="#80c51定时器工作模式" class="headerlink" title="80c51定时器工作模式"></a>80c51定时器工作模式</h2><p>   80c51系列单片机有2个16位的定时器&#x2F;计数器：定时器0（T0），定时器1（T1） 都有定时器或事件计数的功能<br>   T0由两个特殊功能寄存器TH0和TL0构成，T1则由TH1和TL1构成，均是16位加法计数结构<br>   作计数器时，通过引脚T0(P3.4)和T1(P3.5)对外部脉冲信号计数，当输入脉冲信号从1到0的负跳变时，计数器就自动加1，计数的最高频率一般为振荡频率的1&#x2F;24<br>   不论是定时或计数工作，定时器T0或T1都不占用CPU时间，除非定时器（计数器）溢出，才可能中断CPU当前操作<br>   每个定时器都需要一个时钟才能工作，8051通过外部晶振提供它，这是Timer的主要时钟源。8051微控制器中的内部电路为定时器提供时钟源，该定时器是连接到微控制器的晶体频率的1&#x2F;12，也称为机器周期频率。<br>   8051定时器时钟<br>   例如，假设我们的晶振频率为11.0592 MHz，那么微控制器将提供1&#x2F;12即：<br>   定时器时钟频率&#x3D;（Xtal Osc.frequency）&#x2F; 12 &#x3D;（11.0592 MHz）&#x2F; 12 &#x3D; 921.6 KHz<br>   周期T &#x3D; 1 &#x2F;（921.6KHz）&#x3D;1.085μS<br>   方式0为13位的计数器，由TL0的低5位和TH0的8位组成，TL0的高3位未用，TL0低5位计数溢出时向TH0进位，TH0计数溢出时，向中断标志位TF0进位(硬件置位TF0)，并申请中断。T0是否溢出可查询TF0是否被置位，以产生T0中断。<br>   方式0定时，定时时间为：to&#x3D;(213- Xo) xTm&#x3D;(213-X0) x(12&#x2F; fosc)<br>   式中X0为计数初值，Tm为机器周期，fosc为 晶振频率。方式0计数时，最大计数值为2^13&#x3D;8192 (个外部脉冲)   –end</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>arm</category>
      
      <category>s3c2410</category>
      
      <category>51单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
